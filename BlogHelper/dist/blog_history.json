[
  {
    "timestamp": "2025-11-15T19:29:31.915054",
    "title": "VT-d技术浅析及反作弊分析",
    "date": "2025-11-15T19:28:57+08:00",
    "tags": [
      "game security",
      "kernel",
      "vt-d"
    ],
    "content": "### DMAR表定位\n\n> `InitializeAcpiTable`\n\n根据DMAR表头的signiture定位\n![image-20251115192541631](https://liangcha666.oss-cn-beijing.aliyuncs.com/ReverseBlog/image-20251115192541631.png)\n![image-20251115192549203](https://liangcha666.oss-cn-beijing.aliyuncs.com/ReverseBlog/image-20251115192549203.png)\n\n### DMAR预处理 && VT-d初始化\n\n>`InitializeVtdFromDmar`\n\n遍历DMAR表，解析所有DRHD(DMA Remapping Hardware Unit Definition)的信息。同时校验相关寄存器的合法性，检查DMA Remapping是否正确开启，包括：\n\n- Capability Register\n- Global Status Register\n- **Root Table Address Register**\n- Protected Memory Enable Register\n\n在此过程中会同时收集并保存相关的寄存器地址，初始化VT-d Context\n![image-20251115192642315](https://liangcha666.oss-cn-beijing.aliyuncs.com/ReverseBlog/image-20251115192642315.png)\n\n### VT-d 开启\n\n这一部分被vm不方便分析，根据后面的VT-d卸载以及[该开源项目]([tandasat/HelloIommuPkg: The sample DXE runtime driver demonstrating how to program DMA remapping.](https://github.com/tandasat/HelloIommuPkg/tree/master))推断出大致的逻辑。完美大概率也参考了此项目\n\n这一步包括：\n\n- 建表(Root Table和Context Table)\n- 写入RTAR（Root Table Address Register）\n- 执行IOTLB invalidate/ Context invalidate\n- 使能VT-d\n\n#### 建表\n\n注意这里没有显式配置ContextEntry.TranslationType，默认为00b，即采用二级页表进行转换的模式\n\n```c++\nSTATIC\nVOID\nBuildPassthroughTranslations (\n\n    OUT VTD_CONTEXT* VtdContext,\n\n    IN CONST EXTENDED_PAGE_TABLES* ExtendedPageTables\n\n    )\n\n{\n\n    VTD_ROOT_ENTRY rootEntry;\n\n    VTD_CONTEXT_ENTRY contextEntry;\n\n  \n\n    ASSERT(((UINT64)ExtendedPageTables % SIZE_4KB) == 0);\n\n  \n\t//\n\t// 填充root table，让所有的root entries指向同一个context table\n\t//\n\t\n    rootEntry.Upper64.AsUInt = rootEntry.Lower64.AsUInt = 0;\n\n    rootEntry.Lower64.Present = TRUE;\n\n    rootEntry.Lower64.ContextTablePointer =\n\n        gOs->GetPhysicalAddress(gOs, VtdContext->ContextTable) >> MV_PAGE_SHIFT;\n\n    for (UINT64 bus = 0; bus < ARRAY_SIZE(VtdContext->RootTable); bus++)\n\n    {\n\n        VtdContext->RootTable[bus] = rootEntry;\n\n    }\n\n  \n\n\t//\n\t// 填充context table，控制所有的context entries指向同一个二级PML4\n\t// 在这里使用的是EPT，因为该项目用了EPT来控制读写权限\n\t// 寻址流程：GPA --> Root Table --> Context Table --> SLPML4 --> ...\n\t//\n\t// 由于这里所有的context entries都指向了同样的地址，所以可以简单的domain id置1 \n\t// 完美的生产级实现可能更复杂，但核心原理只需要保证每个domain都不映射游戏地址\n\t// 即可实现对游戏的保护\n\t//\n\t\n    contextEntry.Upper64.AsUInt = contextEntry.Lower64.AsUInt = 0;\n\n    contextEntry.Lower64.Present = TRUE;\n\n    contextEntry.Lower64.SecondLevelPageTranslationPointer =\n\n        gOs->GetPhysicalAddress(gOs, &ExtendedPageTables->Pml4) >> MV_PAGE_SHIFT;\n\n    contextEntry.Upper64.AddressWidth = BIT1;  // 010b: 48-bit AGAW (4-level page table) 表示采用四级页表\n\n    contextEntry.Upper64.DomainIdentifier = 1;\n\n    for (UINT64 i = 0; i < ARRAY_SIZE(VtdContext->ContextTable); i++)\n\n    {\n\n        VtdContext->ContextTable[i] = contextEntry;\n\n    }\n\n}\n```\n\n#### 写入RTAR && 刷新页表Cache && 使能VT-d\n\n这一步向VT-d硬件写入Root Table地址（类似CR3）。刷新TLB\n\n```c++\nSTATIC\nVOID\nEnableDmaRemapping (\n\n    IN CONST DMAR_UNIT_INFORMATION* DmarUnit,\n\n    IN CONST VTD_ROOT_ENTRY* RootTable\n\n    )\n\n{\n\n    UINT32 status;\n\n    VTD_ROOT_TABLE_ADDRESS_REGISTER rootTableAddressReg;\n\n  \n\t// 这里的断言是根据Intel手册设置的\n\t// 即当设置Root Table地址时，VT-d必须是禁用状态\n\n    MV_HOST_ASSERT(MV_IS_FLAG_SET(MmioRead32(DmarUnit->RegisterBaseVa + VTD_GLOBAL_STATUS),                                  VTD_GLOBAL_STATUS_TRANSLATION_ENABLE_STATUS_FLAG) == FALSE);\n\n  \n\n\t//\n\t// 设置Root Table地址\n\t// 类比到CR3操作中，其实就是mov cr3,cr3_value;\n\t//\n\n    MV_HOST_DEBUG(\"Setting the root table pointer to %p (VA: %p)\", VaToPa(RootTable), RootTable);\n\n    rootTableAddressReg.AsUInt = 0;\n\n    rootTableAddressReg.RootTableAddress = VaToPa(RootTable) >> MV_PAGE_SHIFT;\n\n    MmioWrite64(DmarUnit->RegisterBaseVa + VTD_ROOT_TABLE_ADDRESS, rootTableAddressReg.AsUInt);\n\n    status = MmioRead32(DmarUnit->RegisterBaseVa + VTD_GLOBAL_STATUS);\n\n    MmioWrite32(DmarUnit->RegisterBaseVa + VTD_GLOBAL_COMMAND,\n\n                status | VTD_GLOBAL_COMMAND_SET_ROOT_TABLE_POINTER_FLAG);\n\n    while (MV_IS_FLAG_SET(MmioRead32(DmarUnit->RegisterBaseVa + VTD_GLOBAL_STATUS),\n\n                          VTD_GLOBAL_STATUS_ROOT_TABLE_POINTER_STATUS_FLAG) == FALSE)\n\n    {\n\n        CpuPause();\n\n    }\n\n  \n\n\t//\n\t// 这一步也是Intel手册要求的\n\t// 设置新的Root Table后，必须失效Context Cache，否则会读到旧页表\n\t//\n\n    InvalidateContextCache(DmarUnit);\n\n    InvalidateIotlb(DmarUnit);\n\n  \n\n    //\n    // 将TE位（Translation Enable）置1，开启DMA remapping\n    //\n\n    MV_HOST_DEBUG(\"Enabling DMA-remapping\");\n\n    status = MmioRead32(DmarUnit->RegisterBaseVa + VTD_GLOBAL_STATUS);\n\n    MmioWrite32(DmarUnit->RegisterBaseVa + VTD_GLOBAL_COMMAND,\n\n                status | VTD_GLOBAL_COMMAND_TRANSLATION_ENABLE_FLAG);\n\n    while (MV_IS_FLAG_SET(MmioRead32(DmarUnit->RegisterBaseVa + VTD_GLOBAL_STATUS),\n\n                          VTD_GLOBAL_STATUS_TRANSLATION_ENABLE_STATUS_FLAG) == FALSE)\n\n    {\n\n        CpuPause();\n\n    }\n\n}\n```\n\n这一步完成之后，DMA attack尝试读取游戏内存就会通过地址转换重定向到其他地方（可能是空地址区域）；同时，也可以记录尝试读取游戏内存的DMA，实现检测的效果。\n需要注意的一点是，如果反作弊其他的操作影响了EPT页表，需要将这一影响同步至VT-d，如下：\n\n```c++\nVOID\nApplyTranslationChangesToVtd (\n    IN CONST VTD_CONTEXT* VtdContext\n    )\n\n{\n\n    WriteBackDataCacheRange(VtdContext->SecondLevelTableBase, VtdContext->SecondLevelTableSize);\n\n  \n\n    for (UINT64 i = 0; i < VtdContext->DmarUnitCount; ++i)\n\n    {\n\n        CONST DMAR_UNIT_INFORMATION* dmarUnit;\n\n        dmarUnit = &VtdContext->DmarUnits[i];\n\n        InvalidateContextCache(dmarUnit);\n\n        InvalidateIotlb(dmarUnit);\n\n    }\n\n}\n```\n\n### VT-d 卸载\n\n> DisableOrCheckVtd\n\n完美将统计VT-d状态的checker和关闭VT-d的禁用器写在了一个函数\n\n当`operationMode == 2`时，清除pass through条目\n![image-20251115192702198](https://liangcha666.oss-cn-beijing.aliyuncs.com/ReverseBlog/image-20251115192702198.png)\n关闭VT-d\n![image-20251115192705639](https://liangcha666.oss-cn-beijing.aliyuncs.com/ReverseBlog/image-20251115192705639.png)\n在tanda Statoshi的项目中给出了这些功能函数的实现，比起IDA有更好的可读性：\n\n```c++\nSTATIC\nVOID\nDisableDmaRemapping (\n    IN CONST DMAR_UNIT_INFORMATION* DmarUnit\n    )\n{\n\n    UINT32 status;\n    UINT32 command;\n  \n    //\n    // See: 11.4.4.1 Global Command Register\n    //\n\n    MV_HOST_DEBUG(\"Disabling IOMMU\");\n\n    status = MmioRead32(DmarUnit->RegisterBaseVa + VTD_GLOBAL_STATUS);\n\n    status &= 0x96FFFFFF; // Reset the one-shot bits\n\n    command = (status & ~VTD_GLOBAL_COMMAND_TRANSLATION_ENABLE_FLAG);\n\n    MmioWrite32(DmarUnit->RegisterBaseVa + VTD_GLOBAL_COMMAND, command);\n\n    while (MV_IS_FLAG_SET(MmioRead32(DmarUnit->RegisterBaseVa + VTD_GLOBAL_STATUS),\n\n                          VTD_GLOBAL_STATUS_TRANSLATION_ENABLE_STATUS_FLAG) != FALSE)\n\n    {\n\n        CpuPause();\n\n    }\n\n}\n\n```",
    "commit_msg": "发布新文章"
  }
]