[{"content":"前言 本文中的沙箱，均指一个受控、虚拟化的环境，专门用来自动运行、监控和分析可疑程序的行为。传统的沙箱根据监控、收集恶意软件行为的方式，可以分为两种模式：一种是基于API Hook的沙箱，如Cuckoo；一种是基于虚拟化技术(VT-x with EPT)的沙箱，如DrakVuf。\n其中，Cuckoo沙箱通过Inject.exe启动样本并挂起，向其中注入monitor.dll对一百多个Native API做了Inline Hook，收集恶意软件的API的调用信息，再解析这些调用信息，打上对应的行为标签。\n这样做的缺陷很显然：由于monitor.dll与恶意软件共存，再加上Inline Hook的痕迹过于明显，很容易被探测出监控环境的存在。并且，在Ring-3下的Hook能力是很有限的，像ntdll重载、syscall这些方法都能轻易规避Hook，使得沙箱跑不出任何行为。\n因此，本文在Cuckoo沙箱工作原理的基础上进行拓展，从内核Hook的角度出发，设计一个更隐蔽、强大的沙箱（或者说是监控系统），以来减少安全分析员们的工作量。\nETW Hook：核心原理 在64位Windows操作系统上，微软引入了Patch Guard对操作系统中易受攻击的结构、函数进行监控，常规的[SSDT Hook](内核模式 Rootkits，第一部分 | SSDT 钩子 • Adlice 软件 \u0026mdash; KernelMode Rootkits, Part 1 | SSDT hooks • Adlice Software)将会引发蓝屏。因此ETW Hook被提出，其核心原理就是利用ETW在遥测syscall时的**“漏洞”**劫持控制流实现Native API Hook。这一漏洞的成因是PG对一些内核函数指针表监控不严（通常在.data段中），我们可以替换某些指针实现Hook而不触发PG，整个调用链如下：\n本文讲解的这个Hook点来自[Oxygen]([原创]InfinityHook 可兼容最新版windows-软件逆向-看雪论坛-安全社区|非营利性质技术交流社区)以及[Daax](《Fun with another PatchGuard-compliant Hook - Reverse Engineering》 \u0026mdash; Fun with another PatchGuard-compliant Hook - Reverse Engineering)，向他们表示感谢！\n在Ring-3调用系统API后，最终会通过syscall指令进入内核（一般来说已经不用调用门了）。首先进入的就是内核中的KiSystemCall64函数；在这里，如果开启了 syscall Nt Kernel Logger，ETW-Ti就会记录这条系统调用信息，如下：\n在ETW记录系统调用前，会把真实的函数地址暂存在栈上，调用完毕后恢复。这也就给了我们可乘之机，只要在PerfInfoLogSysCallEntry的调用链中寻到一处函数指针替换点，就可以劫持控制流修改栈上暂存的函数地址，从而实现Hook。\n在PerfInfoLogSysCallEntry中同样保存了EventID和EVENT_DESCRIPTOR在栈上：\nF33:501802\n将之作为辅助定位栈上函数地址的Magic Number\n继续跟进到EtwpLogKernelEvent中，会发现一些有意思的函数：\n根据ETW Logger的配置情况，上面的三个函数可能会被执行；最开始的替换点是在EtwpReserveTraceBuffer中的GetCpuClock，但这个函数在高版本Windows已被修复，不适合替换了，因此我们跟进EtwpReserveWithPmcCounters\n这里暴露出一个函数指针的调用，这正是我们想要的，查阅HalPrivateDispatchTable的[结构](Vergilius Project | HAL_PRIVATE_DISPATCH)，替换掉Table + 0x248处的函数指针即可接管控制流，此时在栈上搜索两个Magic Number去定位到系统调用的函数地址并替换就实现了Hook，如下：\n1// 2//@brief 代理函数，劫持栈上的函数地址到自己的函数上，同时也是高频执行函数. 3// 4void ProxyEtwpReserveWithPmcCounters(PVOID Context, ULONGLONG TraceBuff) { 5\tUSHORT Magic = 0xF33;//Magic 1 6\tULONG Signate = 0x501802;//Magic 2 7\tULONG Magic2 = 0x601802; 8#define INFINITYHOOK_MAGIC_501802 ((unsigned long)0x501802) //Win11 23606 以前系统特征码 9#define INFINITYHOOK_MAGIC_601802 ((unsigned long)0x601802) //Win11 23606 及以后系统的特征码 10#define INFINITYHOOK_MAGIC_F33 ((unsigned short)0xF33) 11\tPULONG RspPos = _AddressOfReturnAddress(); 12\tPULONG RspLimit = __readgsqword(0x1a8); 13\t// KPCR-\u0026gt;Pcrb.CurrentThread Type:_KTHREAD* 14\tULONG64 currentThread = __readgsqword(0x188);// OFFSET_KPCR_CURRENT_THREAD 15\tULONG systemCallIndex = *(ULONG*)(currentThread + 0x80);// OFFSET_KTHREAD_SYSTEM_CALL_NUMBER 16 17 18\tdo { 19\tif (KeGetCurrentIrql() \u0026lt;= DISPATCH_LEVEL) { 20\t// 不接管内核调用 21\tif (ExGetPreviousMode() == KernelMode) 22\treturn g_oriHalCollectPmcCounters(Context, TraceBuff); 23\twhile (RspPos \u0026lt;= RspLimit) 24\t{ 25\tif (*((PUSHORT)(RspPos)) == INFINITYHOOK_MAGIC_F33) 26\t{ 27\t// Win11 24H2兼容 28\tif (RspPos[2] == INFINITYHOOK_MAGIC_501802 || RspPos[2] == INFINITYHOOK_MAGIC_601802) 29\t{ 30 31\tfor (; (ULONG64)RspPos \u0026lt;= (ULONG64)RspLimit; ++RspPos) 32\t{ 33\t// 执行到这里则已经确认是SYSCALL的ETW记录，可以开始遍历栈 34 // 找在SSDT表范围内的地址，找到既是SYSCALL的地址 35 36 37\tULONG64* pllValue = (ULONG64*)RspPos; 38\tif ((*pllValue \u0026gt;= PAGE_ALIGN(g_SystemCallTable) \u0026amp;\u0026amp; 39\t(*pllValue \u0026lt;= PAGE_ALIGN(g_SystemCallTable + PAGE_SIZE * 2)))) 40\t{ 41 42\tHANDLE pid = PsGetCurrentProcessId(); 43 44\tif (LogManagerIsTargetProcess(pid)) { 45\t// 此时IRQL == DISPATCH_LEVEL 46\t// 只有目标进程才Hook，其他进程正常放行 47\tProcessSyscall(systemCallIndex, RspPos); 48\treturn g_oriHalCollectPmcCounters(Context, TraceBuff); 49\t} 50\telse { 51\treturn g_oriHalCollectPmcCounters(Context, TraceBuff); 52\t} 53 54 55\t} 56\t} 57\t} 58 59\t} 60\t++RspPos; 61 62\t} 63\t} 64\t} while (FALSE); 65 66\treturn g_oriHalCollectPmcCounters(Context, TraceBuff); 67} 但此时离ETW Hook还差了一步，由于正常来说控制流不会走到Hook点，所以需要参考一些文档手动配置ETW Logger走到我们替换的地方。\nETW Hook：合理的配置 离实现ETW Hook只剩一步，那就是配置ETW Logger使其正确执行到我们想要劫持的EtwpReserveWithPmcCounter，这分为两部分：\n配置ETW NT Kernel Logger以及系统调用事件开启 配置Event Trace类使得控制流走到EtwpReserveWithPmcCounter 第一步不困难，CKCL_TRACE_PROPERTIES是一个相对公开的结构体：\n1// 2//@brief ֹ开启Nt kernel logger etw 3// 4// 5NTSTATUS StartOrStopTrace(BOOLEAN control) { 6\tNTSTATUS status = STATUS_UNSUCCESSFUL; 7\tCKCL_TRACE_PROPERTIES* ckclProperty = 0; 8\tULONG lengthReturned = 0; 9\tdo { 10\t11\tckclProperty = ExAllocatePoolWithTag(NonPagedPool, PAGE_SIZE, POOL_TAG); 12\tif (!ckclProperty) { 13\tDbgPrintEx(77, 0, \u0026#34;Failed to allocate memory for ckcl property.\\n\u0026#34;); 14\tstatus = STATUS_INSUFFICIENT_RESOURCES; 15\tbreak; 16\t} 17\tmemset(ckclProperty, 0, PAGE_SIZE); 18\tUNICODE_STRING tmp = { 0 }; 19\tRtlInitUnicodeString(\u0026amp;tmp, L\u0026#34;Circular Kernel Context Logger\u0026#34;); 20\tckclProperty-\u0026gt;Wnode.BufferSize = PAGE_SIZE; 21\tckclProperty-\u0026gt;Wnode.Flags = WNODE_FLAG_TRACED_GUID; 22\tckclProperty-\u0026gt;ProviderName = tmp; 23\tckclProperty-\u0026gt;Wnode.Guid = CkclSessionGuid; 24\tckclProperty-\u0026gt;Wnode.ClientContext = 1; 25\tckclProperty-\u0026gt;BufferSize = sizeof(ULONG); 26\tckclProperty-\u0026gt;MinimumBuffers = ckclProperty-\u0026gt;MaximumBuffers = 2; 27\tckclProperty-\u0026gt;LogFileMode = EVENT_TRACE_BUFFERING_MODE; 28 29\tstatus = ZwTraceControl(control ? EtwpStartTrace : EtwpStopTrace, ckclProperty, PAGE_SIZE, ckclProperty, PAGE_SIZE, \u0026amp;lengthReturned); 30\t// STATUS_OBJECT_NAME_COLLISION 31\tif (!NT_SUCCESS(status) \u0026amp;\u0026amp; status != STATUS_OBJECT_NAME_COLLISION) { 32\tDbgPrintEx(77, 0, \u0026#34;Failed to enable kernel logger etw trace,status=%x\u0026#34;, status); 33\tbreak; 34\t} 35\tif (control) 36\t{ 37\tckclProperty-\u0026gt;EnableFlags = EVENT_TRACE_FLAG_SYSTEMCALL; 38 39\tstatus = ZwTraceControl(EtwpUpdateTrace, ckclProperty, PAGE_SIZE, ckclProperty, PAGE_SIZE, \u0026amp;lengthReturned); 40\tif (!NT_SUCCESS(status)) 41\t{ 42\tDbgPrintEx(77, 0, \u0026#34;Failed to enable syscall etw, errcode=%x\u0026#34;, status); 43\tStartOrStopTrace(FALSE); 44\tbreak; 45\t} 46\t} 47\t} while (FALSE); 48\tif (ckclProperty) 49\tExFreePool(ckclProperty); 50\treturn status; 51} 对于第二步，由于没有公开的结构文档，所以需要自己配置相关的内容，从上面的代码中抠出条件：\n1Flags \u0026amp; 0x800 \u0026amp;\u0026amp; 2LoggerContext-\u0026gt;PmcData-\u0026gt;HookIdCount != 0 \u0026amp;\u0026amp; 3PmcData-\u0026gt;HookId[index] == HookID 这里的Flags是这样一个Union Struct：\n1union 2 { 3 ULONG Flags; //0x330 4 struct 5 { 6 ULONG Persistent:1; //0x330 7 ULONG AutoLogger:1; //0x330 8 ULONG FsReady:1; //0x330 9 ULONG RealTime:1; //0x330 10 ULONG Wow:1; //0x330 11 ULONG KernelTrace:1; //0x330 12 ULONG NoMoreEnable:1; //0x330 13 ULONG StackTracing:1; //0x330 14 ULONG ErrorLogged:1; //0x330 15 ULONG RealtimeLoggerContextFreed:1; //0x330 16 ULONG PebsTracing:1; //0x330 17 ULONG PmcCounters:1; // 我们关注的位 18 ULONG PageAlignBuffers:1; //0x330 19 ULONG StackLookasideListAllocated:1; //0x330 20 ULONG SecurityTrace:1; //0x330 21 ULONG LastBranchTracing:1; //0x330 22 ULONG SystemLoggerIndex:8; //0x330 23 ULONG StackCaching:1; //0x330 24 ULONG ProviderTracking:1; //0x330 25 ULONG ProcessorTrace:1; //0x330 26 ULONG QpcDeltaTracking:1; //0x330 27 ULONG MarkerBufferSaved:1; //0x330 28 ULONG LargeMdlPages:1; //0x330 29 ULONG ExcludeKernelStack:1; //0x330 30 ULONG BootLogger:1; //0x330 31 }; 32 }; 在[这篇文档中](事件跟踪信息类 \u0026mdash; EVENT_TRACE_INFORMATION_CLASS)告诉我们，需要调用NtSetThreadInformation来设置Flags以及HookID。\n我们跟进NtSetThreadInformation -\u0026gt; EtwSetPerformanceTraceInformation去找到具体的内容\n对照上面的控制流条件以及相关配置文档，需要进行两步操作：\n调用 ZwSetSystemInformation分配一个PMC Profile Source，将Flags.PmcCounters置位 调用ZwSetSystemInfomration设置HookId为0xF33 参考如下代码：\n1// 2//@brief 开启PMC计数器 PerformanceCounter 3// 4NTSTATUS OpenPmcCounter() { 5\tNTSTATUS status = STATUS_SUCCESS; 6\tPEVENT_TRACE_PROFILE_COUNTER_INFORMATION countInfo = 0; 7\tPEVENT_TRACE_SYSTEM_EVENT_INFORMATION eventInfo = 0; 8\tif (!g_isActive)return STATUS_UNSUCCESSFUL; 9\tdo { 10\tcountInfo = ExAllocatePoolWithTag(NonPagedPool, sizeof(EVENT_TRACE_PROFILE_COUNTER_INFORMATION),POOL_TAG); 11\tif (!countInfo) { 12\tDbgPrintEx(77, 0, \u0026#34;Failed to allocate memory for PMC count.\\n\u0026#34;); 13\tstatus = STATUS_INSUFFICIENT_RESOURCES; 14\tbreak; 15\t} 16\tcountInfo-\u0026gt;EventTraceInformationClass = EventTraceProfileCounterListInformation; 17\tcountInfo-\u0026gt;TraceHandle = 2; 18\tcountInfo-\u0026gt;ProfileSource[0] = 1; 19\t//\tSTATUS_WMI_ALREADY_ENABLED 20 // 第一步 21\tstatus = ZwSetSystemInformation(SystemPerformanceTraceInformation, countInfo, sizeof(EVENT_TRACE_PROFILE_COUNTER_INFORMATION)); 22\tif (!NT_SUCCESS(status) \u0026amp;\u0026amp; status != STATUS_WMI_ALREADY_ENABLED) { 23\tDbgPrintEx(77, 0, \u0026#34;Failed to configure PMC counter.status=%x\\n\u0026#34;, status); 24\tbreak; 25\t} 26\t27\teventInfo = ExAllocatePoolWithTag(NonPagedPool, sizeof(EVENT_TRACE_SYSTEM_EVENT_INFORMATION),POOL_TAG); 28\tif (!eventInfo) { 29\tDbgPrintEx(77, 0, \u0026#34;Failed to allocate memory for event info.\\n\u0026#34;); 30\tstatus = STATUS_INSUFFICIENT_RESOURCES; 31\tbreak; 32\t} 33 34\teventInfo-\u0026gt;EventTraceInformationClass = EventTraceProfileEventListInformation; 35\teventInfo-\u0026gt;TraceHandle = 2; 36\teventInfo-\u0026gt;HookId[0] = SyscallHookId;// 0xF33 37\t// 第二步 38\tstatus = ZwSetSystemInformation(SystemPerformanceTraceInformation, eventInfo, sizeof(EVENT_TRACE_SYSTEM_EVENT_INFORMATION)); 39\tif (!NT_SUCCESS(status)) 40\t{ 41\tDbgPrintEx(77,0,\u0026#34;failed to configure pmc event, status=%x\u0026#34;, status); 42\tbreak; 43\t} 44 45\t} while (FALSE); 46\tif (countInfo)ExFreePool(countInfo); 47\tif (eventInfo)ExFreePool(eventInfo); 48\tif (status == STATUS_WMI_ALREADY_ENABLED)return STATUS_SUCCESS; 49\treturn status; 50} 打造一个沙箱 可以说，ETW Hook是一个比较完美的沙箱监控手段。因为其只接管应用态的系统调用，不需要特别过滤内核调用；同时其工作环境皆在内核之中，不会对应用态程序暴露出Hook特征。\n因此我们可以参照Cuckoo，Hook一些常见的NT API来收集恶意软件的行为，然后将之传入我们的3环程序解析成易处理的JSON或者BSON格式的数据，再手写一个分析模块来自动化研究其恶意行为。同时由于我们的Hook运行在调用链的最底层，还可以用该Hook去遥测恶意程序的堆栈信息，检测如Hell's Gate及其变种的Ring-3脱钩手段。\n以下是一个简单的Demo，首先考虑使用MiniFilter框架将收集的调用信息作为日志传入Ring-3\n1// MiniFilter发送数据到 3 环 2NTSTATUS SendToUser(PVOID buffer, ULONG bufSize) { 3\tif (!g_ClientPort) return STATUS_INVALID_DEVICE_STATE; 4 5\tLARGE_INTEGER timeout; 6\ttimeout.QuadPart = -10 * 1000 * 1000; // 1 秒 超时时间 7 8\tNTSTATUS status = FltSendMessage( 9\tg_FilterHandle, 10\t\u0026amp;g_ClientPort, 11\tbuffer, 12\tbufSize, 13\tNULL, 14\tNULL, 15\t\u0026amp;timeout); 16 17\tif (!NT_SUCCESS(status)) { 18\tDbgPrintEx(77, 0, \u0026#34;[%s] failed: 0x%X\\n\u0026#34;, __FUNCTION__,status); 19\t} 20\treturn status; 21} 比如想要监控跨进程的线程创建，可以这么写Hook函数：\n1NTSTATUS DetourNtCreateThreadEx( 2\t_Out_ PHANDLE ThreadHandle, 3\t_In_ ACCESS_MASK DesiredAccess, 4\t_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes, 5\t_In_ HANDLE ProcessHandle, 6\t_In_ PVOID StartRoutine, 7\t_In_opt_ PVOID Argument, 8\t_In_ ULONG CreateFlags, 9\t_In_ ULONG_PTR ZeroBits, 10\t_In_opt_ SIZE_T StackSize, 11\t_In_opt_ SIZE_T MaximumStackSize, 12\t_In_opt_ PVOID AttributeList 13) { 14\t15\tNTSTATUS status = STATUS_SUCCESS; 16 RETURN_IF_NOT_PASSIVE(g_NtCreateThreadEx(ThreadHandle, DesiredAccess, ObjectAttributes, ProcessHandle, StartRoutine, Argument, CreateFlags, ZeroBits, StackSize, MaximumStackSize, AttributeList)); 17 18 StackDetect(); 19\tstatus = g_NtCreateThreadEx(ThreadHandle, DesiredAccess, ObjectAttributes, ProcessHandle, StartRoutine, Argument, CreateFlags, ZeroBits, StackSize, MaximumStackSize, AttributeList); 20 21 HANDLE targetPid = NULL; 22 // cross-process 23 if (NT_SUCCESS(status) \u0026amp;\u0026amp; !_IsCurrentProcessHandle(ProcessHandle) \u0026amp;\u0026amp; NT_SUCCESS(_GetPidFromProcessHandle(ProcessHandle, \u0026amp;targetPid)) \u0026amp;\u0026amp; targetPid != PsGetCurrentProcessId()) { 24 (VOID)LogManagerSetTargetProcess(targetPid, TRUE); 25 SYSCALL_PARAMETER params[MAX_SYSCALL_PARAMETERS]; 26 RtlZeroMemory(params, sizeof(params)); 27 _FillParamHandle(L\u0026#34;TargetPid\u0026#34;, targetPid, \u0026amp;params[0]); 28 _FillParamPtr(L\u0026#34;StartRoutine\u0026#34;, StartRoutine, \u0026amp;params[1]); 29 _FillParamUlong(L\u0026#34;CreateFlags\u0026#34;, CreateFlags, \u0026amp;params[2]); 30 _FillParamImageName(L\u0026#34;ImageName\u0026#34;, targetPid, \u0026amp;params[3]); 31 32 LogManagerSendLog(PsGetCurrentProcessId(), PsGetCurrentThreadId(), L\u0026#34;NtCreateThreadEx\u0026#34;, L\u0026#34;RemoteThread\u0026#34;, status, 4, params); 33 } 34 else { 35 #define THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER 0x4 36 if(CreateFlags == THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER) 37 LogManagerSendLog(PsGetCurrentProcessId(), PsGetCurrentThreadId(), L\u0026#34;NtCreateThreadEx\u0026#34;, L\u0026#34;DetectDebugger\u0026#34;, status, 0, NULL); 38 } 39 InterlockedDecrement(\u0026amp;gHooksActive); 40\treturn status; 41} 普通的ETW Hook是全局的Hook，即所有的应用态系统调用都会被我们接管。因此还需要维护一个ProcessList记录样本的PID；对于跨进程的操作，比如有的样本注入shellcode至白进程，或者释放了新进程并拉起，则需要将新进程的PID也加入到ProcessList中，避免遗漏行为。上文中的LogManagerSetTargetProcess正是在做这件事。\n沙箱拓展：堆栈检测 上文中提到的Hell's Gate指的是一种构造gadget直接调用syscall指令进入内核的手法，能够做到规避3环的挂钩。但这样做导致其堆栈不正常，呈现出malware.exe -\u0026gt; ntoskrnl.exe这样的调用链，因此我们可以在Hook开头加一个堆栈检测，检测其返回地址（存放在TrapFrame中）是否位于正常的模块（如ntdll.dll），否则判为一次恶意调用。\n1// 直接系统调用检测(SYSCALL) 2for (int i = 0; i \u0026lt; MODULE_NUM; i++) { 3\tif (rip \u0026gt;= g_UserModule[i].BaseAddress 4\t\u0026amp;\u0026amp; rip \u0026lt;= (ULONG64)g_UserModule[i].BaseAddress + g_UserModule[i].Size) 5\t{ 6\tabnormalSyscall = FALSE; 7\t// ntdll.dll需特殊判定，对抗间接系统调用 - 检测点1 8\tUNICODE_STRING tmp = { 0 }; 9\tRtlInitUnicodeString(\u0026amp;tmp, L\u0026#34;ntdll.dll\u0026#34;); 10\tif (!RtlCompareUnicodeString(\u0026amp;g_UserModule[i].ModuleName, \u0026amp;tmp, TRUE)) 11\tabnormalSyscall = SpecialDetectSyscall(rip, systemCallIndex, TRUE); 12\tgoto log; 13 14\t} 15log: 16 17\tif (abnormalSyscall) { 18\tSYSCALL_PARAMETER params[1]; 19\tparams[0].Type = 2; 20\tRtlStringCchCopyW(params[0].Name, ARRAYSIZE(params[0].Name), L\u0026#34;name\u0026#34;); 21\tRtlStringCchCopyW((WCHAR*)params[0].Data, ARRAYSIZE(params[0].Data) / sizeof(WCHAR), g_SyscallTable[systemCallIndex].Name); 22\tparams[0].Size = (ULONG)(wcslen(g_SyscallTable[systemCallIndex].Name) * sizeof(WCHAR)); 23\tLogManagerSendLog(PsGetCurrentProcessId(), PsGetCurrentThreadId(), L\u0026#34;Syscall\u0026#34;, L\u0026#34;Abnormal Syscall\u0026#34;, 0, 1, params); 24\t} 从对抗的层面来讲这种检测是有欠缺的，因为现在武器化的SYSCALL通常是间接系统调用，调用链通常为malware.exe -\u0026gt; ntdll.dll -\u0026gt; ntoskrnl.exe，或者更加合法的malware.exe -\u0026gt; kernel32.dll -\u0026gt; ntdll.dll -\u0026gt; ntoskrnl.exe ；更高级别的检测就是检测跳转处是否为正常的CALL，还是恶意软件自己维护的跳板。\n堆栈数据是EDR内存扫描的一个重要指标，但对于沙箱来说，跑出更多的行为才是最重要的，因此这里就不展开讨论了。\n演示 演示的样本为某厂攻击队的样本，采用了间接系统调用的API执行手段，普通的3环Hook无法捕捉到调用\n我仅实现了自动化拉起样本、传递调用数据等功能；更进一步地，可以考虑实现自动化重启虚拟机、分析调用数据并打行为标签、自动提取C2（可以通过网络过滤驱动实现）。\n参考文章及项目 [1] [原创]InfinityHook 可兼容最新版windows-软件逆向-看雪论坛-安全社区|非营利性质技术交流社区\n[2] 《Fun with another PatchGuard-compliant Hook - Reverse Engineering》 \u0026mdash; Fun with another PatchGuard-compliant Hook - Reverse Engineering\n[3] https://github.com/zhutingxf/InfinityHookPro\n[4] https://github.com/Oxygen1a1/InfinityHook_latest\n","permalink":"https://ybliangcha.github.io/posts/etw-hook-based-system-sandbox/","summary":"\u003ch2 id=\"前言\"\u003e前言\u003c/h2\u003e\n\u003cp\u003e本文中的沙箱，均指一个受控、虚拟化的环境，专门用来自动运行、监控和分析可疑程序的行为。传统的沙箱根据监控、收集恶意软件行为的方式，可以分为两种模式：一种是基于\u003cstrong\u003eAPI Hook\u003c/strong\u003e的沙箱，如Cuckoo；一种是基于虚拟化技术(VT-x with EPT)的沙箱，如DrakVuf。\u003c/p\u003e","title":"基于ETW Hook的自动化恶意代码分析沙箱设计"},{"content":"什么是PTE Hook 常规的inlineHook思路是直接修改目标函数的代码，使其先执行我们自己的函数，再跳转回来执行原函数。这种Hook是全局的，即Windows中每一个进程一旦调用被Hook的函数，就会受到我们的影响，也很容易被PatchGuard检查到。\n因此提出一种新的Hook思路，隔离具体进程的四级页表，使我们的Hook不影响全局。当然具体的Hook方法依然是inlineHook\n理论知识 CPU访问物理地址 首先解释一下x64架构下，CPU访问一个虚拟地址（也称线性地址）时的流程。Windows使用了四级页表结构，分别是PML4 (Page Map Level 4)、PDPT (Page Directory Pointer Table)、PD (Page Directory)、PT (Page Table)。我们知道一个虚拟地址共64位，其中高16位是不使用的，因此总共只有48位，这48位按照9-9-9-9-12的结构拆分，前四个9表示四级页表的索引，最后一个12表示一个物理页（通常是4K）的页内偏移，这样CPU就找到了一个虚拟地址对应的物理地址。下面演示一个虚拟地址是如何拆分的。\n1比如这样一个虚拟地址 : 0xfffff8037888e000 2高16位不使用，可以看到全部被置为了1，因此有效地址为 ： 0xf8037888e000 3转为二进制： 1111 1000 0000 0011 0111 1000 1000 1000 1110 0000 0000 0000 4第一个9位: 1 1111 0000 -\u0026gt; 0x1f0 PML4 Index 5第二个9位: 0 0000 1101 -\u0026gt; 0xd\tPDPT Index 6第三个9位: 1 1100 0100 -\u0026gt; 0x1c4\tPT Index 7第四个9位: 0 1000 1110 -\u0026gt; 0x8e\tPD Index 8最后12位页内偏移: 00 0000 0000 -\u0026gt; 0\tOffset CR3寄存器是x64架构下一个重要的系统寄存器，其中存储的值是当前进程PML4表的物理基地址，之前已经计算出Index，因此通过CR3拿到基地址后，可以逐层的索引到物理地址。\n页表自映射 根据上面讲的，我们明白CPU是这样找到物理地址的：PML4-\u0026gt;PDPT-\u0026gt;PD-\u0026gt;PT-\u0026gt;Physical Page，共有4次访问内存。由于CPU寻址是一个高频操作，为了简化这一流程，Windows引入了一个很精妙的机制：页表自映射。\n页表自映射，即在PML4这张表的其中一项中，存储PML4表基地址。比如假设在索引0x100处存储：\n因此，在访问PML4索引0x100处，其实就是在访问PML4自身，所以被称为页表自映射。\n你可能会想，这么做白白浪费了8字节空间，为什么要设置一个这样的页表项，他的精妙之处是这样的：\n我们先从PML4入手，我们知道一个48位有效地址的高9位是PML4的索引，这个索引对应的页表项存储的本应该是下一级页表，即PDPT的物理基地址，但是由于引入了页表自映射，因此就必然有一个索引对应的页表项存储的是PML4自身的基地址，不妨将这一索引设为S（在上图中这个索引是0x100）。\n我们先采用这样的格式表示一个48位的虚拟地址(A)(B)(C)(D)(Offset)，其中A是PML4的索引\n当 A == B == C == D == S \u0026amp;\u0026amp; Offset == 0 时，CPU访问这个虚拟地址时会出现这样的寻址情况：\nPML4 Index == S，指向PML4表物理基地址，PDPT Index == S ，又指向PML4表物理基地址，以此类推，PD和PT也都指向PML4表物理基地址。因此(S)(S)(S)(S)(000000000000)对应的物理地址就是PML4表的物理基地址，不妨把这个虚拟地址称作PML4的表虚拟基地址。用数学公式将之表达：\n1PML4_VirtualBase = (S \u0026lt;\u0026lt; 39) | (S \u0026lt;\u0026lt; 30) | (S \u0026lt;\u0026lt; 21) | (S \u0026lt;\u0026lt; 12) 2//S \u0026lt;\u0026lt; 39 就是将一串48位的二进制数的高9位设为S，或运算就是将每次设置的值连起来放在一个数上 3//假设 S \u0026lt;\u0026lt; 39 == 0xF6E0000000000000 S \u0026lt;\u0026lt; 30 == 0x0000074000000000 4//那么 (S \u0026lt;\u0026lt; 39) | (S \u0026lt;\u0026lt; 30) == 0xF6E0074000000000 根据上面的理论，显然当A == B == C == S \u0026amp;\u0026amp; D == PDPT_Index \u0026amp;\u0026amp; Offset == 0时，也就是说其中一位指向了PDPT的基地址，可以得到PDPT的表虚拟基地址\n1PDPT_VirtualBase = (S \u0026lt;\u0026lt; 39) | (S \u0026lt;\u0026lt; 30) | (S \u0026lt;\u0026lt; 21) | (PDPT_Index \u0026lt;\u0026lt; 12) 以此类推，我们就可以得到计算最低一级的页表PT的表虚拟基地址的计算公式，这里顺便展示PD的计算公式：\n1PT_VirtualBase = (S \u0026lt;\u0026lt; 39) | (PDPT_Index \u0026lt;\u0026lt; 30) | (PD_Index \u0026lt;\u0026lt; 21) | (PT_Index \u0026lt;\u0026lt; 12) 2PD_VirtualBase = (S \u0026lt;\u0026lt; 39) | (S \u0026lt;\u0026lt; 30) | (PDPT_Index) | (PD_Index \u0026lt;\u0026lt; 12) 以上是利用页表自映射机制定位到PT表基地址，实际上也可以利用这个原理定位到任意一个VA（虚拟地址）对应的PTE（Page Table Entry，即PT条目，也即PT表中的一项）。\n显然以下公式成立：\n1PTE_VirtualAddress = (S \u0026lt;\u0026lt; 39) | (PML4_Index \u0026lt;\u0026lt; 30) | (PDPT_Index \u0026lt;\u0026lt; 21) | (PD_Index \u0026lt;\u0026lt; 12) | (PT_Index \u0026lt;\u0026lt; 3) 2/* 3理解最后的(PT_Index \u0026lt;\u0026lt; 3)的这一项，因为每个PTE占8字节，左移3位即乘8，也理解为i*8作为偏移来找到具体的 4的PTE，实际上就是通过自映射机制将PT表当作了原来的物理页面进行查找 5*/ 通过我们构造出的这个虚拟地址，可以直接读写PTE而不需要知道其物理地址。\n最后再将一个很简洁的通过PML4的表虚拟基地址得到其他三级页表虚拟基地址的公式，我们知道：\n1PML4_VirtualBase = (S \u0026lt;\u0026lt; 39) | (S \u0026lt;\u0026lt; 30) | (S \u0026lt;\u0026lt; 21) | (S \u0026lt;\u0026lt; 12) 如果将后两个S置为0，即不考虑偏移且往后找一级页表，就可以得到PDPT的表虚拟基地址\n1PDPT_VirtualBase = (S \u0026lt;\u0026lt; 39) | (S \u0026lt;\u0026lt; 30) | (0 \u0026lt;\u0026lt; 21) | (0 \u0026lt;\u0026lt; 12) 数学上，上面这个式子实际上等价于PML4的虚拟基地址的低21位置0，即\n1PDPT_VirtualBase = (PML4_VirtualBase \u0026gt;\u0026gt; 21) \u0026lt;\u0026lt; 21 同理：\n1PD_VirtualBase = (PML4_VirtualBase \u0026gt;\u0026gt; 30) \u0026lt;\u0026lt; 30 2PT_VirtualBase = (PML4_VirtualBase \u0026gt;\u0026gt; 39) \u0026lt;\u0026lt; 39 另外，由于上面计算VA对应的PTE公式过于复杂，是主动构造了9-9-9-9-12的虚拟地址结构，还有一个通过基地址+偏移的方法来计算：\n1PTE_VirtualAddress = PTE_Base + (VA \u0026gt;\u0026gt; 12) \u0026lt;\u0026lt; 3 2/* 3VA \u0026gt;\u0026gt; 12 其实就是 VA / 4096，我们知道一个页就是4096K，所以VA \u0026gt;\u0026gt; 12 就是虚拟页号，每一页对应一个PTE， 4一个PTE是8字节，那么上式就变成了： 5*/ 6PTE_VirtualAddress = PTE_Base + Offset * 8 由于Windows开启了基址随机化，页表的虚拟基地址每次开机都不一样，因此需要一个巧妙的方法定位页表基地址，这里给出鹅厂的方法：利用页表自映射定位。由于存在页表自映射这一机制，因此，在PML4表的512个地址中，必然有一个存放着PML4的表物理地址，即CR3的值。所以可以通过映射CR3物理地址的虚拟地址，遍历这个地址页面的512个地址，哪个地址等于CR3的值，哪个地址就是PML4的表虚拟基地址。考虑以下算法：\n1ULONG64 GetPml4Base() 2{ 3\tPHYSICAL_ADDRESS pCr3 = { 0 }; 4\tpCr3.QuadPart = __readcr3(); 5\tPULONG64 pCmpArr = (PULONG64)MmGetVirtualForPhysical(pCr3); 6 7\tint count = 0; 8\t/* 9\t*pCmpArr（当前条目，即PML4E的值）表示指向下一级页表的物理地址 10\t\u0026amp;0xFFFFFFFFF000即获取Page_Frame_Number 页帧号 11\t*/ 12\twhile ((*pCmpArr \u0026amp; 0xFFFFFFFFF000) != pCr3.QuadPart) 13\t{ 14\tif (++count \u0026gt;= 512) 15\t{ 16\treturn -1; 17\t} 18\tpCmpArr++; 19\t} 20 21\treturn (ULONG64)pCmpArr \u0026amp; 0xFFFFFFFFFFFFF000;//忽略后12位标志位 22} 理论知识就到这里了。\nPTE Hook原理 首先思考一个问题，为什么常规Hook只是修改了一个进程的内核函数，却导致全局的内核函数被修改而被PG检查到。这是因为，用户态下的进程对应的PML4表的高256项都是相同的，指向了共享的内核PDPT，一旦我们修改任意一项PTE，就会产生连锁的影响PT-\u0026gt;PD-\u0026gt;PDPT-\u0026gt;PML4，又由于PML4是共享的，所以全局的函数都被修改了。\n因此我们可以先替换掉一项PML4E，这一项PML4E被我们替换后，指向一个伪造的PDPT表，再指向一个伪造的PD表，一个伪造的PT表，最后指向我们Hook的函数。这样被修改的函数只局限于这一个进程，在一定程度上可以规避PG。\n此外，还需要考虑大小页的问题。小页指的就是一般的4K大小的页，大页指的是2M的页，是操作系统为了提高访问内存性能而开发的。根据上面的伪造替换规则，一般来说会想到：大页换大页，小页换小页。但是由于页表的物理内存必然是连续的，而Windows的物理内存机制是碎片化的，开机越久越难申请到2M的连续内存，所以考虑使用页表分割的方法，即将一个2M的大页分成512个小页。在如下的代码中，我们只申请了一页连续的内存，用来存放指向512个小页的PTE，每个都用来指向原大页的不同4K部分。\n实战 页表分割：\n1bool splitLargePages(pde_64* in_pde, pde_64* out_pde) 2{ 3\tPHYSICAL_ADDRESS MaxAddrPa{ 0 }, LowAddrPa{ 0 }; 4\tMaxAddrPa.QuadPart = MAXULONG64; 5\tLowAddrPa.QuadPart = 0; 6\tpt_entry_64* Pt; 7\tauto start_pfn = in_pde-\u0026gt;page_frame_number; 8\tPt = (pt_entry_64*)MmAllocateContiguousMemorySpecifyCache(PAGE_SIZE, LowAddrPa, MaxAddrPa, LowAddrPa, MmCached);//默认对齐 9\tif (!Pt) { 10\tDbgPrintEx(77, 0, \u0026#34;failed to alloc contiguous for new pt.\\r\\n\u0026#34;); 11\treturn false; 12\t} 13\tfor (int i = 0; i \u0026lt; 512; i++) { 14\t//分割成小页，构建Pt 15\tPt[i].flags = in_pde-\u0026gt;flags; 16\tPt[i].large_page = 0; 17\tPt[i].global = 0; 18\tPt[i].page_frame_number = start_pfn + i; 19\t} 20\tout_pde-\u0026gt;flags = in_pde-\u0026gt;flags; 21\tout_pde-\u0026gt;large_page = 0; 22\tout_pde-\u0026gt;page_frame_number = va_to_pa(Pt) / PAGE_SIZE; 23\treturn true; 24} 下面是页表伪造部分的代码：\n1typedef struct _PTE_TABLE { 2 void* LineAddress; 3 pte_64* PteAddress; 4 pde_64* PdeAddress; 5 pdpte_64* PdpteAddress; 6 pml4e_64* Pml4eAddress; 7}PTE_TABLE, * PPTE_TABLE; 1bool isolationPageTable(cr3 cr3_reg, void* replaceAlignAddr, pde_64* splitPDE) 2{ 3\t//均指向4kb内存 4\tuint64_t* VaPt, * Va4kb, * VaPdt, * VaPdpt, * VaPml4t; 5 6\tPTE_TABLE Table{ 0 }; 7\tPHYSICAL_ADDRESS MaxAddrPa{ 0 }, LowAddrPa{ 0 }; 8\tMaxAddrPa.QuadPart = MAXULONG64; 9\tLowAddrPa.QuadPart = 0; 10\t//这里申请伪造页表的内存 11\tVaPt = (uint64_t*)MmAllocateContiguousMemorySpecifyCache(PAGE_SIZE, LowAddrPa, MaxAddrPa, LowAddrPa, MmCached); 12\tVa4kb = (uint64_t*)MmAllocateContiguousMemorySpecifyCache(PAGE_SIZE, LowAddrPa, MaxAddrPa, LowAddrPa, MmCached); 13\tVaPdt = (uint64_t*)MmAllocateContiguousMemorySpecifyCache(PAGE_SIZE, LowAddrPa, MaxAddrPa, LowAddrPa, MmCached); 14\tVaPdpt = (uint64_t*)MmAllocateContiguousMemorySpecifyCache(PAGE_SIZE, LowAddrPa, MaxAddrPa, LowAddrPa, MmCached); 15\tVaPml4t = (uint64_t*)pa_to_va(cr3_reg.address_of_page_directory * PAGE_SIZE); 16 17\tif (!VaPt || !Va4kb || !VaPdt || !VaPdpt) { 18\tDbgPrintEx(77, 0, \u0026#34;failed to alloc page table entry.\\r\\n\u0026#34;); 19\treturn false; 20\t} 21\tTable.LineAddress = replaceAlignAddr; 22\tgetPagesTable(Table);//这个函数是利用理论知识讲的公式获取任意VA对应的PTE、PDPTE、PDE、PXE 23 24\t//获取索引 25\tUINT64 pml4eindex = ((uint64_t)replaceAlignAddr \u0026amp; 0x0000FF8000000000) \u0026gt;\u0026gt; 39; 26\tUINT64 pdpteindex = ((uint64_t)replaceAlignAddr \u0026amp; 0x0000007FC0000000) \u0026gt;\u0026gt; 30; 27\tUINT64 pdeindex = ((uint64_t)replaceAlignAddr \u0026amp; 0x000000003FE00000) \u0026gt;\u0026gt; 21; 28\tUINT64 pteindex = ((uint64_t)replaceAlignAddr \u0026amp; 0x00000000001FF000) \u0026gt;\u0026gt; 12; 29 30\t//判断是否为大页，因为大页的PT是没有值的，所以要将VaPt指向分割成小页后的PT表，就是上面代码展示的 31\tif (Table.PdeAddress-\u0026gt;large_page) { 32\tMmFreeContiguousMemorySpecifyCache(VaPt, PAGE_SIZE, MmCached); 33\tVaPt = (uint64_t*)pa_to_va(splitPDE-\u0026gt;page_frame_number * PAGE_SIZE); 34\t} 35\telse { 36\t//小页，Pt数组是有值的，先复制 37\tmemcpy(VaPt, Table.PteAddress - pteindex, PAGE_SIZE); 38\t} 39 //这里我的Table结构中的页表均为指针，因此这里做的减法是指针减法，不需要乘以8 40 //另外这里做减法的意思是获取页表的起始地址，即基地址 41\tmemcpy(Va4kb, replaceAlignAddr, PAGE_SIZE); 42\tmemcpy(VaPdt, Table.PdeAddress - pdeindex, PAGE_SIZE);//指针减法 43\tmemcpy(VaPdpt, Table.PdpteAddress - pdpteindex, PAGE_SIZE); 44 45\t//替换页表的页框号，从Pte开始一直到Pml4e 46\t_disable();//关中断防止替换被打断 47\tauto pReplacePte = (pte_64*)\u0026amp;VaPt[pteindex]; 48\tpReplacePte-\u0026gt;page_frame_number = va_to_pa(Va4kb) / PAGE_SIZE; 49\tauto pReplacePde = (pde_64*)\u0026amp;VaPdt[pdeindex]; 50\tpReplacePde-\u0026gt;page_frame_number = va_to_pa(VaPt) / PAGE_SIZE; 51\tpReplacePde-\u0026gt;large_page = 0; 52\tpReplacePde-\u0026gt;ignored_1 = 0; 53\tpReplacePde-\u0026gt;page_level_cache_disable = 1; 54\tauto pReplacePdpte = (pdpte_64*)\u0026amp;VaPdpt[pdpteindex]; 55\tpReplacePdpte-\u0026gt;page_frame_number = va_to_pa(VaPdt) / PAGE_SIZE; 56\tauto pReplacePml4e = (pml4e_64*)\u0026amp;VaPml4t[pml4eindex]; 57\tpReplacePml4e-\u0026gt;page_frame_number = va_to_pa(VaPdpt) / PAGE_SIZE; 58 59\t//刷新TLB 60\t__invlpg(pReplacePml4e); 61 62\t_enable(); 63\treturn true; 64 65} 最后写一段代码调用上面两个函数：\n1bool isolationPages(HANDLE pid, void* iso_address) 2{ 3\tif (!MmIsAddressValid(iso_address)) { 4\tDbgPrintEx(77, 0, \u0026#34;Invalid address: %p\\r\\n\u0026#34;, iso_address); 5\treturn false; 6\t} 7 8\tPEPROCESS Process; 9\tKAPC_STATE Apc{ 0 }; 10\tNTSTATUS status; 11\tvoid* AliginIsoAddr; 12\tPTE_TABLE Table{ 0 }; 13\tstatus = PsLookupProcessByProcessId(pid, \u0026amp;Process); 14\t//附加要隔离的进程，每个进程的空间是独立的，这一步一定要做 15\tKeStackAttachProcess(Process, \u0026amp;Apc); 16\tAliginIsoAddr = PAGE_ALIGN(iso_address); 17\tTable.LineAddress = AliginIsoAddr; 18 19\tgetPagesTable(Table); 20 21\tbool bSuc = false; 22\twhile (1) { 23\t//大页分割 24\tpde_64 splitPDE{ 0 }; 25\tif (Table.PdeAddress-\u0026gt;large_page) { 26\tbSuc = splitLargePages(Table.PdeAddress, \u0026amp;splitPDE); 27\tif (!bSuc)break; 28\tif (Table.PdeAddress-\u0026gt;flags \u0026amp; 0x100) { 29\tTable.PdeAddress-\u0026gt;flags \u0026amp;= ~0x100; 30 /* 31 这里以及下面的的Table.PteAddress-\u0026gt;global = 0;是在关闭G位 32 */ 33\t} 34\t} 35\telse { 36\tif (Table.PteAddress-\u0026gt;global) { 37\tTable.PteAddress-\u0026gt;global = 0; 38\t} 39\t} 40 41\tcr3 Cr3; 42\tCr3.flags = __readcr3(); 43\tbSuc = isolationPageTable(Cr3, AliginIsoAddr, \u0026amp;splitPDE); 44 45\tif (bSuc) { 46\tDbgPrintEx(77, 0, \u0026#34;isolation succeed.\\r\\n\u0026#34;); 47\tbreak; 48\t} 49\telse { 50\tDbgPrintEx(77, 0, \u0026#34;failed to isolation pages.\\r\\n\u0026#34;); 51\tbreak; 52\t} 53\t} 54\tKeUnstackDetachProcess(\u0026amp;Apc); 55\tObDereferenceObject(Process); 56\treturn bSuc; 57} 这里有一步之前没讲的操作，设置了G位。在CPU的内部有一个表叫做TLB，学过计组的都知道，这玩意叫做快表，其实是一个Cache，内部记录了很多东西，比如直接记录一个虚拟地址对应的物理地址，而不需要通过四级页表机制来查找。每次切换进程时，CR3都会改变，而TLB是跟着CR3变的。但是由于操作系统的高位映射是基本不变的，如果每次切换CR3都重新维护一个TLB，就会造成很大开销。因此诞生了Global，即全局位。这个位一旦被置1，那么切换进程CR3的时候，就不会刷新PDE或PTE的G位为1的页。这将导致：进程A切换到进程B，而进程A的某个虚拟地址还是保存在进程B的TLB中，下次进程B查找这个虚拟地址的值后，就会在TLB中找到进程A虚拟地址中对应的物理地址。\n这对我们的隔离操作是有害的， 因为若进程A恰好是我们隔离的进程，我们Hook了某个函数后，其他进程又从TLB中找到了被Hook的这个函数，那么隔离就失效了。因此，我们关闭伪造页对应的PTE或PDE的G位，强制切换进程时刷新TLB，其他进程就找不到我们的Hook了。\n讲完上面的代码，PTE Hook的核心进程隔离部分已经实现了，接下来只需要使用inlineHook框架就好了。下面是一个例子：\n1bool PTEHookManager::PTEHook(HANDLE pid, void** oFuncAddr, void* targetFuncAddr) 2{ 3\tstatic bool bFirst = true; 4\tif (bFirst) { 5\tm_PTEBase = nullptr; 6\tm_trampLine = (char*)ExAllocatePoolWithTag(NonPagedPool, PAGE_SIZE * 5, \u0026#39;Line\u0026#39;); 7\tif (!m_trampLine) { 8\tDbgPrintEx(77, 0, \u0026#34;failed to create trampline.\\r\\n\u0026#34;); 9\treturn false; 10\t} 11\tmemset(\u0026amp;m_info, 0, sizeof(m_info)); 12\tmemset(\u0026amp;m_globalBit, 0, sizeof(m_globalBit)); 13\tm_trampLineUsed = 0; 14\tbFirst = false; 15\t} 16\tPEPROCESS Process{ 0 }; 17\tKAPC_STATE Apc{ 0 }; 18\tNTSTATUS status; 19\tconst uint32_t breakBytesLeast = 14;//ff 25 20\tconst uint32_t trampLineBreakBytes = 20; 21\tuint32_t uBreakBytes = 0; 22\tchar* TrampLine = m_trampLine + m_trampLineUsed; 23\thde64s hde_info{ 0 }; 24\tchar* JmpAddrStart = (char*)*oFuncAddr; 25\tif (m_curHookCount == MAX_HOOK_COUNT) { 26\tDbgPrintEx(77, 0, \u0026#34;Hook too many.\\r\\n\u0026#34;); 27\treturn false; 28\t} 29\tstatus = PsLookupProcessByProcessId(pid, \u0026amp;Process); 30\tif (!NT_SUCCESS(status)) { 31\tDbgPrintEx(77, 0, \u0026#34;failed to get pid.\\r\\n\u0026#34;); 32\treturn false; 33\t} 34\tauto ret = isolationPages(pid, *oFuncAddr); 35\tif (!ret)return false; 36\tDbgPrintEx(77, 0, \u0026#34;ready to diasm.\\r\\n\u0026#34;); 37\twhile (uBreakBytes \u0026lt; breakBytesLeast) { 38\tif (!hde64_disasm(JmpAddrStart + uBreakBytes, \u0026amp;hde_info)) { 39\tDbgPrintEx(77, 0, \u0026#34;failed to diasm addr.\\r\\n\u0026#34;); 40\tObDereferenceObject(Process); 41\treturn false; 42\t} 43\tuBreakBytes += hde_info.len; 44\t} 45\tDbgPrintEx(77, 0, \u0026#34;finish disasm.\\r\\n\u0026#34;); 46\tunsigned char trampLineCode[trampLineBreakBytes] = { 47\t0x6A, 0x00, // push 0 48\t0x3E, 0xC7, 0x04, 0x24, 0x00, 0x00, 0x00, 0x00, // mov dword ptr ss : [rsp] , 0x00 49\t0x3E, 0xC7, 0x44, 0x24, 0x04, 0x00, 0x00, 0x00, 0x00, // mov dword ptr ss : [rsp + 4] , 0x00 50\t0xC3\t// ret 51\t}; 52\tchar absolutejmpCode[14] = { 0xFF,0x25,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 }; 53\t*((PUINT32)\u0026amp;trampLineCode[6]) = (UINT32)(((uint64_t)JmpAddrStart + uBreakBytes) \u0026amp; 0XFFFFFFFF); 54\t*((PUINT32)\u0026amp;trampLineCode[15]) = (UINT32)((((uint64_t)JmpAddrStart + uBreakBytes) \u0026gt;\u0026gt; 32) \u0026amp; 0XFFFFFFFF); 55 56\tmemcpy(TrampLine, JmpAddrStart, uBreakBytes); 57\tmemcpy(TrampLine + uBreakBytes, trampLineCode, trampLineBreakBytes); 58\t//添加Hook信息 59\tfor (int i = 0; i \u0026lt; MAX_HOOK_COUNT; i++) { 60\tif (m_info[i].pid == 0) { 61\tm_info[i].oriAddr = JmpAddrStart; 62\tmemcpy(m_info[i].oriBytes, JmpAddrStart, 14); 63\tm_info[i].pid = pid; 64\tm_curHookCount++; 65\tbreak; 66\t} 67\t} 68\tDbgPrintEx(77, 0, \u0026#34;ready to create trampline.\\r\\n\u0026#34;); 69\t*((ULONG64*)(\u0026amp;absolutejmpCode[6])) = (ULONG64)targetFuncAddr; 70\tKeStackAttachProcess(Process, \u0026amp;Apc); 71\t//auto oIrpl = WPOFF(); 72\t//memcpy(JmpAddrStart, absolutejmpCode, 14); 73\t//DbgPrintEx(77, 0, \u0026#34;[JmpAddrStart]%p\\r\\n\u0026#34;,JmpAddrStart); 74\tDbgPrintEx(77, 0, \u0026#34;[absolutejmpCode]\u0026#34;); 75\tfor (int i = 0; i \u0026lt; 14; i++) { 76\tDbgPrintEx(77, 0, \u0026#34;%02X\u0026#34;, (unsigned char)absolutejmpCode[i]); 77\t} 78\tDbgPrintEx(77, 0, \u0026#34;\\r\\n\u0026#34;); 79\tBOOLEAN success = MDLWriteMemory(JmpAddrStart, absolutejmpCode, 14); 80\tif (!success) { 81\tDbgPrintEx(77, 0, \u0026#34;failed to MDL write jmpcode.\\r\\n\u0026#34;); 82\treturn false; 83\t} 84\tKeUnstackDetachProcess(\u0026amp;Apc); 85\t*oFuncAddr = TrampLine; 86\tm_trampLineUsed += uBreakBytes + trampLineBreakBytes; 87\tObDereferenceObject(Process); 88\treturn true; 89} 下面我尝试Hook explore.exe进程的NtCreateFile函数看看效果，系统版本：Win10 1903，另外我还测试了Win10 21H2、Win11 21H2，挂了6小时左右未出现PG\n1NTSTATUS HookNtCreateFile( 2 OUT PHANDLE FileHandle, 3 IN ACCESS_MASK DesiredAccess, 4 IN POBJECT_ATTRIBUTES ObjectAttributes, 5 OUT PIO_STATUS_BLOCK IoStatusBlock, 6 IN PLARGE_INTEGER AllocationSize OPTIONAL, 7 IN ULONG FileAttributes, 8 IN ULONG ShareAccess, 9 IN ULONG CreateDisposition, 10 IN ULONG CreateOptions, 11 IN PVOID EaBuffer OPTIONAL, 12 IN ULONG EaLength) 13{ 14 DbgPrintEx(77, 0, \u0026#34;[+]Create Files.\\r\\n\u0026#34;); 15 if (ObjectAttributes \u0026amp;\u0026amp; ObjectAttributes-\u0026gt;ObjectName \u0026amp;\u0026amp; ObjectAttributes-\u0026gt;ObjectName-\u0026gt;Buffer) { 16 wchar_t* name = (wchar_t*)ExAllocatePoolWithTag(NonPagedPool, ObjectAttributes-\u0026gt;ObjectName-\u0026gt;Length + sizeof(wchar_t), \u0026#39;name\u0026#39;); 17 RtlZeroMemory(name, ObjectAttributes-\u0026gt;ObjectName-\u0026gt;Length + sizeof(wchar_t)); 18 RtlCopyMemory(name, ObjectAttributes-\u0026gt;ObjectName-\u0026gt;Buffer, ObjectAttributes-\u0026gt;ObjectName-\u0026gt;Length); 19 if (wcsstr(name, L\u0026#34;MyHook.txt\u0026#34;)) { 20 ExFreePool(name); 21 return STATUS_ACCESS_DENIED; 22 } 23 ExFreePool(name); 24 } 25 26 return g_OriginNtCreateFile(FileHandle, DesiredAccess, ObjectAttributes, IoStatusBlock, AllocationSize, FileAttributes, ShareAccess, CreateDisposition, CreateOptions, EaBuffer, EaLength); 27} 效果图：\n结语 PTE Hook其实已经是一种比较古老的方法了，不过研究完之后，我觉得对于x64架构的认识以及Windows内核的入门还挺有帮助的。\n","permalink":"https://ybliangcha.github.io/posts/pte-hook-analysis/","summary":"\u003ch3 id=\"什么是pte-hook\"\u003e什么是PTE Hook\u003c/h3\u003e\n\u003cp\u003e常规的inlineHook思路是直接修改目标函数的代码，使其先执行我们自己的函数，再跳转回来执行原函数。这种Hook是全局的，即Windows中每一个进程一旦调用被Hook的函数，就会受到我们的影响，也很容易被PatchGuard检查到。\u003c/p\u003e","title":"PTE Hook原理浅析"},{"content":"BUPT 天枢Dubhe Team Member\nFocus on:\nWindows Internal Security Game Hacking \u0026amp;\u0026amp; Anti-Cheat Red Team Tools Develop Contact me : mail@0xloft.com\n","permalink":"https://ybliangcha.github.io/about/","summary":"about","title":"关于"}]